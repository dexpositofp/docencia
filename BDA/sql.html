<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aplicaciones Web — HTML</title>
  <link rel="stylesheet" href="./bd.css">
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&family=Playfair+Display:wght@700&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
  <meta name="description" content="Unidad de HTML: estructura, semántica, formularios, tablas, multimedia y validación.">
</head>
<body>

<header class="topbar" role="banner">
  <div class="wrap">
    <div class="site-brand">
      <a href="./index.html">Bases de Datos</a>
      <small>1º DAW</small>
    </div>

    <button class="topnav-toggle" aria-expanded="false" aria-controls="topnav">
      <span class="sr-only">Abrir menú</span>
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M4 7h16M4 12h16M4 17h16" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
      </svg>
    </button>

     <nav id="topnav" class="topnav" aria-label="Site navigation">
      <ul>
        <li><a href="index.html" class="active">Inicio</a></li>
        <li><a href="almacenamiento.html">Almacenamiento</a></li>
        <li><a href="conceptual.html">Diseño Conceptual</a></li>
        <li><a href="logico.html">Diseño Lógico</a></li>
        <li><a href="sql.html">SQL</a></li>
        <li><a href="plsql.html">PL/SQL</a></li>
        <li><a href="persistencia.html">Persistencia</a></li>
        <li><a href="nosql.html">NoSQL</a></li>
    </ul>
    </nav>
    
  </div>
</header>

<div class="layout">
  <aside class="sidebar" id="sidebar" aria-label="Unit index">
    <h2>Contents</h2>
    <nav>
      <ul class="toc" id="toc">
        <li><a href="#objetivos">Objetivos</a></li>
                <li><a href="#competencias">1. Competencias</a></li>
                <li><a href="#contenidos">2. Contenidos</a></li>
                <li><a href="#metodologia">3. Metodología</a></li>
                <li><a href="#evaluacion">4. Evaluación</a></li>
      </ul>
    </nav>
  </aside>

  <div class="backdrop" id="backdrop" hidden></div>

  
    <!-- Contenido principal -->
    <main class="content">
        <header class="page">
        <h1 id="intro">SQL — Lenguaje de consulta estructurado</h1>
        <p class="muted">Este tema introduce SQL desde cero y lo organiza en cuatro familias de instrucciones: <strong>DDL</strong><span class="badge">definir</span>, <strong>DML</strong><span class="badge">leer/escribir</span>, <strong>DCL</strong><span class="badge">permisos</span> y <strong>TCL</strong><span class="badge">transacciones</span>. A lo largo de la unidad alternaremos explicación y ejemplos (PostgreSQL y MySQL/MariaDB) exactamente como yo lo haría en clase.</p>
      </header>

      <!-- ===================== 1. INTRO ===================== -->
      <section id="intro">
        <h2>1. Introducción a SQL</h2>
        <p>
          <strong>SQL (Structured Query Language)</strong> es el lenguaje estándar para trabajar con bases de datos relacionales. Nació a principios de los 70 en IBM (proyecto System R) a partir del modelo relacional de E. F. Codd, y en los 80 se estandarizó por ANSI/ISO. Desde entonces, todos los SGBDR (Sistemas de Gestión de Bases de Datos Relacionales) —como <em>PostgreSQL, MySQL/MariaDB, Oracle, SQL Server</em>— implementan SQL con pequeñas diferencias de dialéctos. SQL es <em>declarativo</em>: tú dices <em>qué</em> necesitas y el motor decide <em>cómo</em> obtenerlo.
        </p>
        <div class="callout tip">
          <strong>Idea clave.</strong> Piensa en SQL como en cuatro sombreros distintos:
          <ul>
            <li><strong>DDL</strong>: crear y modificar la <em>estructura</em> (bases de datos, tablas, columnas, índices, claves).</li>
            <li><strong>DML</strong>: insertar, consultar, actualizar y borrar <em>datos</em>.</li>
            <li><strong>DCL</strong>: otorgar o revocar <em>permisos</em>.</li>
            <li><strong>TCL</strong>: gestionar <em>transacciones</em> (confirmar o deshacer cambios).</li>
          </ul>
        </div>
        <h3>SQL en el ciclo de vida de una aplicación</h3>
        <p>
          En un proyecto típico empezamos levantando el <em>esquema</em> (DDL), cargamos datos de prueba (DML), definimos usuarios y privilegios (DCL) y, por último, nos aseguramos de que los cambios sean <strong>atómicos</strong> y consistentes mediante transacciones (TCL). Este orden no es rígido, pero ayuda a estructurar mentalmente el trabajo.
        </p>
        <div class="demo">
            <pre><code>CREATE TABLE autores (
            id SERIAL PRIMARY KEY,
            nombre VARCHAR(80) NOT NULL
            );
            CREATE TABLE libros (
            id SERIAL PRIMARY KEY,
            isbn CHAR(13) NOT NULL UNIQUE,
            titulo VARCHAR(120) NOT NULL,
            autor_id INT NOT NULL REFERENCES autores(id)
            );
            CREATE INDEX idx_libros_isbn ON libros(isbn);
            </code></pre>
            </details>
            </li>
            <li>
            <strong>Consultas con JOIN y agregación.</strong> Obtén el top 3 de clientes por gasto total y el número medio de líneas por pedido.
            <details><summary>Solución orientativa</summary>
            <pre><code>SELECT c.nombre, SUM(p.total) AS total
            FROM clientes c JOIN pedidos p ON p.cliente_id = c.id
            GROUP BY c.id
            ORDER BY total DESC
            LIMIT 3;
            
            
            SELECT AVG(cnt) AS media_lineas
            FROM (
            SELECT COUNT(*) AS cnt FROM lineas_pedido GROUP BY pedido_id
            ) t;
            </code></pre>
            </details>
            </li>
            <li>
            <strong>Transacciones.</strong> Simula un alta de pedido con fallo intermedio y deja la BD consistente usando <code>SAVEPOINT</code>.
            </li>
            </ol>
        
            
            
            <!-- ===================== Recursos ===================== -->
            
            <h3>Recursos y buenas prácticas</h3>
            <ul>
            <li>Escribe sentencias <em>idempotentes</em> en despliegues: <code>CREATE TABLE IF NOT EXISTS</code>, <code>DROP ... IF EXISTS</code>.</li>
            <li>Versiona el esquema con migraciones (p. ej., Flyway, Liquibase) incluso en proyectos pequeños.</li>
            <li>Incluye <code>EXPLAIN</code>/<code>EXPLAIN ANALYZE</code> en tu rutina para entender planes de ejecución.</li>
            <li>Evita <code>SELECT *</code> en producción: carga columnas necesarias y documenta contratos.</li>
            <li>Centraliza constantes y validaciones en la BD siempre que tenga sentido.</li>
            </ul>
            </section>
            
            <!-- ===================== 2.b DDL MYSQL A FONDO ===================== -->
<section id="ddl">
    <h2>2. DDL</h2>
    <p>
      En esta sección nos ponemos el «sombrero DDL» <strong>centradas 100% en MySQL 8.0+</strong>. Veremos desde la creación de bases de datos hasta el diseño fino de tablas, tipos de datos, claves primarias y ajenas, índices, opciones de motor y el tratamiento de <code>NULL</code>. La idea es que, al terminar, puedas leer y escribir DDL con criterio, sabiendo <em>por qué</em> eliges cada opción.
    </p>
  
    <h3>1) Crear bases de datos (charset y collation)</h3>
    <p>
      En MySQL, <code>CREATE DATABASE</code> y <code>CREATE SCHEMA</code> son sinónimos. Es clave fijar la <strong>codificación</strong> y la <strong>ordenación</strong> desde el principio. Para español moderno recomiendo <code>utf8mb4</code> con una collation insensible a mayúsculas y acentos (p. ej., <code>utf8mb4_0900_ai_ci</code> o, si la tienes, <code>utf8mb4_es_0900_ai_ci</code>).
    </p>
  <pre><code>-- Crear la base y usarla
  CREATE DATABASE IF NOT EXISTS tienda
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_0900_ai_ci;  -- alternativa: utf8mb4_es_0900_ai_ci
  USE tienda;
  
  -- Inspeccionar la definición
  SHOW CREATE DATABASE tienda\G
  </code></pre>
    <p class="muted">Consejo: también puedes definir charset/collation por <em>tabla</em> o por <em>columna</em> si necesitas comportamientos distintos.</p>
  
    <h3>2) Motores de almacenamiento (ENGINE)</h3>
    <p>
      El motor de almacenamiento decide cómo se guardan y bloquean los datos. <strong>InnoDB</strong> es el motor por defecto y el recomendado: soporta <em>transacciones</em>, <em>claves ajenas</em>, <em>bloqueo a nivel de fila</em> y <em>recuperación</em>. Otros motores existen (MEMORY, ARCHIVE, etc.) pero tienen usos muy específicos y limitaciones (p. ej., sin FKs). Lo normal en 1º DAW es usar siempre InnoDB.
    </p>
  <pre><code>-- Motor por tabla
  CREATE TABLE ejemplo (
    id INT PRIMARY KEY
  ) ENGINE=InnoDB;
  </code></pre>
  
    <h3>3) Tipos de datos en MySQL (elección didáctica)</h3>
    <p>
      Elegir bien los tipos evita sorpresas. Abajo tienes una «chuleta» con los más usados y cuándo elegirlos. Recuerda: para <em>dinero</em> usa <code>DECIMAL(p,s)</code>; para contadores <code>INT</code>/<code>BIGINT</code>; para textos libres <code>VARCHAR(n)</code> o <code>TEXT</code> si pueden ser muy largos; para fechas <code>DATE</code> y para fecha-hora sin zona horaria <code>DATETIME</code> (o <code>TIMESTAMP</code> si te interesa el auto-update y aceptas su rango limitado).
    </p>
    <div class="demo">
      <table>
        <thead>
          <tr><th>Categoría</th><th>Tipos comunes</th><th>Notas prácticas</th></tr>
        </thead>
        <tbody>
          <tr>
            <td>Números enteros</td>
            <td><code>TINYINT</code>, <code>SMALLINT</code>, <code>INT</code>, <code>BIGINT</code></td>
            <td>Elige el más pequeño que cubra el rango. <code>BOOLEAN</code> es alias de <code>TINYINT(1)</code>.</td>
          </tr>
          <tr>
            <td>Números exactos</td>
            <td><code>DECIMAL(p,s)</code></td>
            <td>Para importes: p.ej., <code>DECIMAL(10,2)</code>. Evita <code>FLOAT/DOUBLE</code> en dinero.</td>
          </tr>
          <tr>
            <td>Números en coma flotante</td>
            <td><code>FLOAT</code>, <code>DOUBLE</code></td>
            <td>Para cálculos científicos o medidas aproximadas.</td>
          </tr>
          <tr>
            <td>Cadenas</td>
            <td><code>CHAR(n)</code>, <code>VARCHAR(n)</code>, <code>TINYTEXT/TEXT/MEDIUMTEXT/LONGTEXT</code></td>
            <td><code>CHAR</code> para longitudes fijas (códigos); <code>VARCHAR</code> para variable; <code>TEXT</code> para textos largos.</td>
          </tr>
          <tr>
            <td>Binarios</td>
            <td><code>BINARY(n)</code>, <code>VARBINARY(n)</code>, <code>BLOB</code>…</td>
            <td>Para datos binarios. Suele preferirse guardar ficheros fuera de la BD.</td>
          </tr>
          <tr>
            <td>Fecha y hora</td>
            <td><code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, <code>TIMESTAMP</code></td>
            <td><code>TIMESTAMP</code> puede auto-actualizarse (<code>DEFAULT CURRENT_TIMESTAMP</code>, <code>ON UPDATE</code>) pero su rango es ~1970-2038. <code>DATETIME</code> tiene rango amplio.</td>
          </tr>
          <tr>
            <td>JSON</td>
            <td><code>JSON</code></td>
            <td>Valida formato y permite funciones JSON. Úsalo para datos semiestructurados, no como sustituto del modelado relacional.</td>
          </tr>
          <tr>
            <td>Enumerados</td>
            <td><code>ENUM</code>, <code>SET</code></td>
            <td>Útiles pero rígidos: valorar tabla de referencia + FK si cambiarán.</td>
          </tr>
          <tr>
            <td>Espaciales</td>
            <td><code>POINT</code>, <code>GEOMETRY</code>…</td>
            <td>Fuera del alcance básico, pero existen e incluso tienen índices espaciales.</td>
          </tr>
        </tbody>
      </table>
    </div>
  
    <h3>4) Crear tablas bien formadas</h3>
    <p>
      A continuación definimos un esquema tipo «tienda» con <strong>claves primarias</strong>, <strong>únicas</strong>, <strong>foráneas</strong>, <strong>checks</strong>, <strong>columnas generadas</strong> e <strong>índices</strong>. Fíjate en el uso de <code>ENGINE</code>, <code>CHARACTER SET</code>, <code>COLLATE</code> y los nombres explícitos de las restricciones (<code>CONSTRAINT ...</code>).
    </p>
  <pre><code>-- CLIENTES
  CREATE TABLE IF NOT EXISTS clientes (
    id            INT AUTO_INCREMENT,
    nombre        VARCHAR(80)     NOT NULL,
    email         VARCHAR(120)    NOT NULL,
    telefono      VARCHAR(20)     NULL,
    fecha_alta    DATE            NOT NULL DEFAULT (CURRENT_DATE),
    activo        TINYINT(1)      NOT NULL DEFAULT 1,
    nif           VARCHAR(12)     NULL,
    -- Restricciones
    CONSTRAINT pk_clientes PRIMARY KEY (id),
    CONSTRAINT uq_clientes_email UNIQUE (email),
    CONSTRAINT uq_clientes_nif   UNIQUE (nif),
    CONSTRAINT chk_email_arroba  CHECK (email LIKE '%@%')
  ) ENGINE=InnoDB
    DEFAULT CHARSET=utf8mb4
    COLLATE=utf8mb4_0900_ai_ci;
  
  -- PEDIDOS
  CREATE TABLE IF NOT EXISTS pedidos (
    id            INT AUTO_INCREMENT,
    cliente_id    INT            NOT NULL,
    fecha_pedido  DATETIME       NOT NULL DEFAULT CURRENT_TIMESTAMP,
    estado        ENUM('pendiente','enviado','cancelado','entregado') NOT NULL DEFAULT 'pendiente',
    total         DECIMAL(10,2)  NOT NULL DEFAULT 0,
    CONSTRAINT pk_pedidos PRIMARY KEY (id),
    CONSTRAINT fk_pedidos_cliente FOREIGN KEY (cliente_id)
      REFERENCES clientes(id)
      ON UPDATE CASCADE
      ON DELETE RESTRICT,
    KEY idx_pedidos_cliente (cliente_id)
  ) ENGINE=InnoDB;
  
  -- LÍNEAS DE PEDIDO (PK compuesta + columna generada)
  CREATE TABLE IF NOT EXISTS lineas_pedido (
    pedido_id   INT           NOT NULL,
    posicion    INT           NOT NULL,
    producto    VARCHAR(80)   NOT NULL,
    cantidad    INT           NOT NULL CHECK (cantidad &gt; 0),
    precio      DECIMAL(10,2) NOT NULL CHECK (precio &gt;= 0),
    importe     DECIMAL(10,2) AS (cantidad * precio) STORED,
    CONSTRAINT pk_lineas PRIMARY KEY (pedido_id, posicion),
    CONSTRAINT fk_lineas_pedido FOREIGN KEY (pedido_id)
      REFERENCES pedidos(id)
      ON UPDATE CASCADE
      ON DELETE CASCADE
  ) ENGINE=InnoDB;
  </code></pre>
  
    <div class="callout info">
      <strong>Sobre CHECK.</strong> En MySQL 8.0.16+ las restricciones <code>CHECK</code> se <em>aplican</em>. En versiones antiguas se aceptaban pero se ignoraban. Si trabajas con una versión vieja, sustitúyelas por claves y lógica alternativa.
    </div>
  
    <h3>5) Claves primarias y AUTO_INCREMENT</h3>
    <p>
      Una <strong>PK</strong> identifica de forma única cada fila. En MySQL conviene que la PK sea <em>compacta y monótona</em> (p. ej., <code>INT AUTO_INCREMENT</code>) para favorecer el índice clustered de InnoDB. También puedes usar PK compuestas cuando tengan significado natural (como <code>(pedido_id, posicion)</code> en líneas).
    </p>
  <pre><code>-- PK simple autoincremental
  CREATE TABLE categorias (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(60) NOT NULL UNIQUE
  ) ENGINE=InnoDB;
  
  -- PK compuesta
  CREATE TABLE favoritos (
    cliente_id INT NOT NULL,
    producto_id INT NOT NULL,
    PRIMARY KEY (cliente_id, producto_id)
  ) ENGINE=InnoDB;
  </code></pre>
  
    <h3>6) Claves ajenas (FOREIGN KEY) y acciones</h3>
    <p>
      Las FKs garantizan integridad referencial. Define siempre la acción adecuada: <code>ON DELETE RESTRICT</code> (bloquea borrado), <code>ON DELETE CASCADE</code> (borra hijas), <code>ON DELETE SET NULL</code> (pone <code>NULL</code> si lo permites) o <code>NO ACTION</code> (equivalente práctico a <code>RESTRICT</code> en MySQL). Para <code>SET NULL</code>, la columna debe permitir <code>NULL</code>.
    </p>
  <pre><code>-- SET NULL requiere permitir nulos
  ALTER TABLE pedidos
    ADD COLUMN comercial_id INT NULL,
    ADD CONSTRAINT fk_pedidos_comercial FOREIGN KEY (comercial_id)
    REFERENCES comerciales(id)
    ON DELETE SET NULL;
  </code></pre>
  
    <h3>7) NULOS: reglas que debes interiorizar</h3>
    <ul>
      <li><strong><code>NULL</code> ≠ 0 ≠ ''</strong>. Representa «valor desconocido». No compares con <code>=</code>; usa <code>IS NULL</code> / <code>IS NOT NULL</code>.</li>
      <li>Una columna sin <code>NOT NULL</code> <em>acepta</em> nulos. Define <code>NOT NULL</code> siempre que el dato sea obligatorio.</li>
      <li>Un índice <strong>UNIQUE</strong> permite múltiples <code>NULL</code> (porque <code>NULL</code> no es igual a <code>NULL</code>).</li>
      <li>Para <code>ON DELETE SET NULL</code> la columna debe ser <code>NULL</code>-able.</li>
      <li>Usa <code>DEFAULT</code> para valores por defecto coherentes (fechas, flags, importes en 0).</li>
    </ul>
  <pre><code>-- Ejemplos rápidos
  CREATE TABLE ejemplo_nulos (
    a INT UNIQUE NULL,      -- admite varios NULL
    b INT NOT NULL UNIQUE   -- no admite NULL
  );
  
  -- Búsqueda correcta
  SELECT * FROM ejemplo_nulos WHERE a IS NULL;  -- no uses a = NULL
  </code></pre>
  
    <h3>8) Índices (UNIQUE, compuestos, FULLTEXT)</h3>
    <p>
      En InnoDB, la PK es el índice clustered. Crea índices secundarios para acelerar filtros y joins frecuentes. Mejor un índice compuesto bien pensado que varios índices sueltos. Para búsqueda de texto libre en columnas <code>VARCHAR/TEXT</code>, puedes usar <code>FULLTEXT</code>.
    </p>
  <pre><code>-- Índice compuesto (cliente + fecha)
  CREATE INDEX idx_pedidos_cliente_fecha ON pedidos(cliente_id, fecha_pedido);
  
  -- Texto libre
  CREATE FULLTEXT INDEX ft_productos_nombre ON productos(nombre);
  
  -- Prefijos (cuando la columna es muy larga)
  CREATE INDEX idx_usuarios_email_pref ON usuarios(email(20));
  </code></pre>
  
    <h3>9) ALTER TABLE: evolucionar el esquema</h3>
    <p>
      MySQL ofrece varias formas de alterar: <code>ADD</code>, <code>DROP</code>, <code>MODIFY</code> (cambia tipo/atributos), <code>CHANGE</code> (cambia nombre y tipo), <code>RENAME COLUMN</code> (8.0+), añadir/quitar restricciones e índices. Para eliminar una FK debes conocer su <em>nombre</em> simbólico.
    </p>
  <pre><code>-- Añadir columnas y restricciones
  ALTER TABLE clientes
    ADD COLUMN apellidos VARCHAR(120) AFTER nombre,
    ADD CONSTRAINT chk_nombre_long CHECK (CHAR_LENGTH(nombre) &gt;= 2);
  
  -- Cambiar tipo y NOT NULL
  ALTER TABLE clientes MODIFY telefono VARCHAR(25) NULL;
  
  -- Renombrar columna (8.0+)
  ALTER TABLE clientes RENAME COLUMN telefono TO telefono_movil;
  
  -- Añadir/quitar índice
  ALTER TABLE pedidos ADD UNIQUE uq_pedidos (cliente_id, fecha_pedido);
  ALTER TABLE pedidos DROP INDEX uq_pedidos;
  
  -- Quitar FK (necesitas el nombre)
  ALTER TABLE pedidos DROP FOREIGN KEY fk_pedidos_cliente;
  </code></pre>
    <div class="callout tip">
      <strong>¿Cómo sé el nombre de una FK o índice?</strong> Usa <code>SHOW CREATE TABLE nombre</code> o consulta <code>INFORMATION_SCHEMA</code> (<code>TABLE_CONSTRAINTS</code>, <code>KEY_COLUMN_USAGE</code>).
    </div>
  
    <h3>10) Comentarios, opciones y otras herramientas</h3>
    <ul>
      <li><strong>Comentarios:</strong> añade <code>COMMENT 'texto'</code> en columnas y tablas para documentar.</li>
      <li><strong>Opciones de tabla:</strong> <code>ROW_FORMAT</code>, <code>AUTO_INCREMENT</code>, <code>ENGINE</code>, <code>CHARSET</code>, etc.</li>
      <li><strong>Vistas:</strong> aunque son DDL, las veremos aparte; útiles para exponer «lecturas» estables a la capa de aplicación.</li>
      <li><strong>Buenas prácticas de despliegue:</strong> usa <code>CREATE/DROP ... IF EXISTS</code> y versiona las migraciones.</li>
    </ul>
  
    <div class="callout warn">
      <strong>Antipatrones frecuentes.</strong>
      <ol>
        <li>Usar <code>VARCHAR(255)</code> por defecto «porque sí». Elige tamaños razonables.</li>
        <li>Abusar de <code>ENUM</code>; es sencillo al principio pero rígido para cambios.</li>
        <li>Sin claves ajenas «porque las controlo en la app». La BD <em>debe</em> hacer cumplir la integridad.</li>
        <li>Olvidar el charset/collation y mezclar luego columnas con reglas diferentes.</li>
      </ol>
    </div>
  
    <h3>11) Práctica guiada (mini-reto)</h3>
    <p>
      Diseña el DDL de un pequeño módulo de «cursos»: <em>cursos</em>(id, título, precio), <em>alumnos</em>(id, nombre, email) y <em>matriculas</em>(curso_id, alumno_id, fecha, precio_pagado). Requisitos: emails únicos, precio no negativo, PK compuesta en <code>matriculas</code>, FK con <code>ON DELETE CASCADE</code> y columna generada <code>iva</code> = 21% de <code>precio_pagado</code> (STORED).
    </p>
    <details><summary>Solución orientativa</summary>
  <pre><code>CREATE TABLE cursos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    titulo VARCHAR(120) NOT NULL,
    precio DECIMAL(10,2) NOT NULL CHECK (precio &gt;= 0)
  ) ENGINE=InnoDB;
  
  CREATE TABLE alumnos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(120) NOT NULL,
    email VARCHAR(120) NOT NULL UNIQUE
  ) ENGINE=InnoDB;
  
  CREATE TABLE matriculas (
    curso_id  INT NOT NULL,
    alumno_id INT NOT NULL,
    fecha     DATE NOT NULL DEFAULT (CURRENT_DATE),
    precio_pagado DECIMAL(10,2) NOT NULL CHECK (precio_pagado &gt;= 0),
    iva DECIMAL(10,2) AS (ROUND(precio_pagado * 0.21, 2)) STORED,
    PRIMARY KEY (curso_id, alumno_id),
    CONSTRAINT fk_mat_curso  FOREIGN KEY (curso_id)  REFERENCES cursos(id)  ON DELETE CASCADE,
    CONSTRAINT fk_mat_alumno FOREIGN KEY (alumno_id) REFERENCES alumnos(id) ON DELETE CASCADE
  ) ENGINE=InnoDB;
  </code></pre>
    </details>
  </section>
  <!-- ===================== 3.b DML MYSQL A FONDO ===================== -->
<section id="dml-select">
    <h2>3. DML: Consultas</h2>
    <p>
      En esta unidad profundizamos en <strong>DML</strong>: <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> y <code>DELETE</code>. Iremos de menos a más: primero consultas sobre <em>una tabla</em>, después <em>agrupaciones</em>, y finalmente trabajaremos con <em>varias tablas</em> (joins) y <em>subconsultas</em>. Todo con <strong>MySQL 8.0+</strong> en mente y usando el esquema del tema (<em>clientes</em>, <em>pedidos</em>, <em>lineas_pedido</em>). Añadiremos además una tabla <em>productos</em> para practicar.
    </p>
  
    <div class="callout tip">
      <strong>Recordatorio.</strong> Orden lógico de evaluación: <code>FROM</code> → <code>WHERE</code> → <code>GROUP BY</code> → <code>HAVING</code> → <code>SELECT</code> → <code>ORDER BY</code> → <code>LIMIT</code>. Te servirá para entender por qué ciertas referencias no funcionan en <code>WHERE</code> pero sí en <code>HAVING</code> o en la proyección final.
    </div>
  
    <h3>0) Preparación: datos de ejemplo rápidos</h3>
  <pre><code>-- Tabla de apoyo para consultas
  CREATE TABLE IF NOT EXISTS productos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(80) NOT NULL,
    categoria VARCHAR(40) NOT NULL,
    precio DECIMAL(10,2) NOT NULL CHECK (precio &gt;= 0),
    stock INT NOT NULL DEFAULT 0 CHECK (stock &gt;= 0)
  ) ENGINE=InnoDB;
  
  INSERT INTO productos (nombre, categoria, precio, stock) VALUES
    ('Libro BBDD', 'libros', 38.50, 50),
    ('Ratón', 'perifericos', 20.00, 120),
    ('Teclado', 'perifericos', 29.90, 80),
    ('Portátil 14\"', 'equipos', 799.00, 10),
    ('USB-C 32GB', 'almacenamiento', 9.99, 200);
  
  -- Algunos clientes/pedidos de ejemplo
  INSERT INTO clientes (nombre, email) VALUES
    ('Ada Lovelace','ada@ejemplo.com'),
    ('Linus Torvalds','linus@ejemplo.com'),
    ('Radia Perlman','radia@ejemplo.com');
  
  INSERT INTO pedidos (cliente_id, estado, total)
  VALUES (1,'pendiente',0), (2,'enviado',58.50);
  
  INSERT INTO lineas_pedido (pedido_id, posicion, producto, cantidad, precio) VALUES
    (2,1,'Libro BBDD',1,38.50),
    (2,2,'Ratón',1,20.00);
  </code></pre>
  
    <h3>1) Consultas sobre <em>una tabla</em> (SELECT básico)</h3>
    <p>
      Empezamos con <strong>proyección</strong> (elegir columnas), <strong>filtros</strong> (<code>WHERE</code>), <strong>ordenación</strong> (<code>ORDER BY</code>) y <strong>paginación</strong> (<code>LIMIT/OFFSET</code>). Añadimos alias con <code>AS</code> y expresiones básicas.
    </p>
  <pre><code>-- Columnas concretas + alias + expresión calculada
  SELECT id, nombre AS producto, precio, stock, (precio * stock) AS valor_stock
  FROM productos;
  
  -- Filtrado: operadores (=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=), AND/OR/NOT, IN/BETWEEN/LIKE, IS NULL
  SELECT id, nombre, precio
  FROM productos
  WHERE categoria IN ('perifericos','almacenamiento')
    AND precio BETWEEN 10 AND 40
    AND nombre LIKE '%o%';
  
  -- Ordenación múltiple y paginación
  SELECT id, nombre, categoria, precio
  FROM productos
  ORDER BY categoria ASC, precio DESC
  LIMIT 5 OFFSET 0;
  
  -- Eliminar duplicados con DISTINCT
  SELECT DISTINCT categoria FROM productos ORDER BY categoria;
  
  -- Manejo de NULL: COALESCE / IFNULL
  SELECT c.id, c.nombre, COALESCE(c.telefono, '—') AS telefono
  FROM clientes c;
  </code></pre>
  
    <div class="callout info">
      <strong>Truco con NULL al ordenar.</strong> MySQL no tiene <code>NULLS FIRST/LAST</code>, pero puedes simularlo: 
      <code>ORDER BY (col IS NULL) ASC, col ASC</code> (primero no nulos).
    </div>
  
    <h3>2) Funciones habituales (números, cadenas y fechas)</h3>
    <p>
      Recuerda: en MySQL las funciones se escriben como <code>NOMBRE(argumentos)</code>. Las más usadas en 1º DAW:
    </p>
    <div class="demo">
      <table>
        <thead><tr><th>Categoría</th><th>Funciones típicas</th><th>Ejemplos</th></tr></thead>
        <tbody>
          <tr>
            <td>Números</td>
            <td><code>ROUND</code>, <code>FLOOR</code>, <code>CEIL</code>, <code>ABS</code></td>
            <td><code>SELECT ROUND(AVG(precio),2) FROM productos;</code></td>
          </tr>
          <tr>
            <td>Cadenas</td>
            <td><code>CONCAT</code>, <code>SUBSTRING</code>, <code>LENGTH</code>, <code>UPPER/LOWER</code>, <code>TRIM</code>, <code>REPLACE</code></td>
            <td><code>SELECT CONCAT(UPPER(nombre),' (',categoria,')') FROM productos;</code></td>
          </tr>
          <tr>
            <td>Fechas</td>
            <td><code>NOW</code>, <code>CURDATE</code>, <code>DATE_FORMAT</code>, <code>DATEDIFF</code>, <code>TIMESTAMPDIFF</code></td>
            <td><code>SELECT TIMESTAMPDIFF(DAY, fecha_pedido, NOW()) AS dias FROM pedidos;</code></td>
          </tr>
          <tr>
            <td>Control</td>
            <td><code>COALESCE</code>, <code>IFNULL</code>, <code>CASE WHEN</code></td>
            <td><code>CASE WHEN stock=0 THEN 'sin stock' ELSE 'ok' END</code></td>
          </tr>
        </tbody>
      </table>
    </div>
  
    <h3>3) Agregación: <code>GROUP BY</code> y <code>HAVING</code></h3>
    <p>
      Las agregaciones resumen varias filas en una. Usa <code>GROUP BY</code> con <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code>. Filtra grupos con <code>HAVING</code> (no con <code>WHERE</code>).
    </p>
  <pre><code>-- Ventas por cliente (incluyendo clientes sin pedidos con LEFT JOIN)
  SELECT c.id, c.nombre,
         COALESCE(SUM(p.total),0) AS total_cliente,
         COUNT(p.id) AS num_pedidos
  FROM clientes c
  LEFT JOIN pedidos p ON p.cliente_id = c.id
  GROUP BY c.id, c.nombre
  ORDER BY total_cliente DESC;
  
  -- Solo clientes con &gt;= 1 pedido y total &gt; 50€
  SELECT c.nombre, SUM(p.total) AS total
  FROM clientes c
  JOIN pedidos p ON p.cliente_id = c.id
  GROUP BY c.id, c.nombre
  HAVING COUNT(p.id) &gt;= 1 AND SUM(p.total) &gt; 50;
  
  -- Agregación por categoría de producto
  SELECT categoria,
         COUNT(*) AS num_productos,
         ROUND(AVG(precio),2) AS precio_medio
  FROM productos
  GROUP BY categoria
  ORDER BY precio_medio DESC;
  
  -- Totales con WITH ROLLUP (suma por categoría y total general)
  SELECT categoria, SUM(precio) AS suma
  FROM productos
  GROUP BY categoria WITH ROLLUP;
  </code></pre>
  
    <div class="callout warn">
      <strong>Regla de oro.</strong> En MySQL, si activas <em>sql_mode</em> estricto (recomendado), toda columna en la lista <code>SELECT</code> debe estar en <code>GROUP BY</code> o ser una agregación. Evita depender de extensiones no estándar.
    </div>
  
    <h3>4) Varias tablas: <em>joins</em> explicados</h3>
    <p>
      Para combinar tablas relacionadas usamos <strong>JOIN</strong>. Siempre pon alias cortos a las tablas y especifica la condición con <code>ON</code>.
    </p>
    <div class="demo">
      <table>
        <thead><tr><th>Tipo</th><th>Qué devuelve</th><th>Esquema mental</th></tr></thead>
        <tbody>
          <tr><td><code>INNER JOIN</code></td><td>Solo coincidencias en ambas tablas</td><td>A ∩ B</td></tr>
          <tr><td><code>LEFT JOIN</code></td><td>Todos los de la izquierda, y datos de la derecha si existen</td><td>A + (A∩B)</td></tr>
          <tr><td><code>RIGHT JOIN</code></td><td>Simétrico al anterior</td><td>B + (A∩B)</td></tr>
          <tr><td><code>CROSS JOIN</code></td><td>Producto cartesiano (útil con cuidado)</td><td>A × B</td></tr>
        </tbody>
      </table>
    </div>
  <pre><code>-- INNER JOIN: pedidos con su cliente
  SELECT p.id, c.nombre, p.fecha_pedido, p.estado, p.total
  FROM pedidos p
  INNER JOIN clientes c ON c.id = p.cliente_id
  ORDER BY p.fecha_pedido DESC;
  
  -- LEFT JOIN: clientes sin pedidos (mirando NULL)
  SELECT c.id, c.nombre
  FROM clientes c
  LEFT JOIN pedidos p ON p.cliente_id = c.id
  WHERE p.id IS NULL;
  
  -- RIGHT JOIN: (menos usado; preferimos reordenar tablas y usar LEFT)
  SELECT p.id, c.nombre
  FROM pedidos p
  RIGHT JOIN clientes c ON c.id = p.cliente_id;
  
  -- FULL OUTER JOIN (MySQL no lo tiene nativo): emulación con UNION
  SELECT c.id, c.nombre, p.id AS pedido_id
  FROM clientes c LEFT JOIN pedidos p ON p.cliente_id = c.id
  UNION
  SELECT c.id, c.nombre, p.id AS pedido_id
  FROM clientes c RIGHT JOIN pedidos p ON p.cliente_id = c.id;
  
  -- SELF JOIN: clientes con mismo dominio de email (ejemplo didáctico)
  SELECT c1.id, c1.email, c2.id, c2.email
  FROM clientes c1
  JOIN clientes c2 ON c1.id &lt; c2.id AND SUBSTRING_INDEX(c1.email,'@',-1)=SUBSTRING_INDEX(c2.email,'@',-1);
  </code></pre>
  
    <h3>5) Subconsultas: <em>IN</em>, <em>EXISTS</em>, escalares y correlacionadas</h3>
    <p>
      Una subconsulta puede devolver un escalar (una columna/una fila), una columna (para <code>IN</code>), varias columnas (en <code>EXISTS</code>) o una tabla derivada en <code>FROM</code>. En MySQL 8.0 también disponemos de <strong>CTE</strong> con <code>WITH</code>.
    </p>
  <pre><code>-- Escalar: clientes con gasto &gt; gasto medio
  SELECT c.*
  FROM clientes c
  WHERE (
    SELECT COALESCE(AVG(p.total),0) FROM pedidos p WHERE p.cliente_id = c.id
  ) &gt; (
    SELECT AVG(total) FROM pedidos
  );
  
  -- IN: clientes que han hecho algún pedido
  SELECT * FROM clientes
  WHERE id IN (SELECT DISTINCT cliente_id FROM pedidos);
  
  -- EXISTS: equivalente, a menudo más eficiente
  SELECT c.* FROM clientes c
  WHERE EXISTS (SELECT 1 FROM pedidos p WHERE p.cliente_id = c.id);
  
  -- Correlacionada: pedidos por encima de la media del mismo cliente
  SELECT p.*
  FROM pedidos p
  WHERE p.total &gt; (
    SELECT AVG(p2.total) FROM pedidos p2
    WHERE p2.cliente_id = p.cliente_id
  );
  
  -- Subconsulta en FROM (tabla derivada)
  SELECT t.cliente_id, t.num_pedidos, t.total
  FROM (
    SELECT cliente_id, COUNT(*) AS num_pedidos, SUM(total) AS total
    FROM pedidos
    GROUP BY cliente_id
  ) AS t
  ORDER BY t.total DESC;
  
  -- CTE (WITH): top 5 clientes por gasto (idéntico a tabla derivada, pero más legible)
  WITH gasto AS (
    SELECT cliente_id, SUM(total) AS total
    FROM pedidos
    GROUP BY cliente_id
  )
  SELECT c.nombre, g.total
  FROM gasto g JOIN clientes c ON c.id = g.cliente_id
  ORDER BY g.total DESC
  LIMIT 5;
  </code></pre>
  
    <h3>6) Inserciones (<code>INSERT</code>)</h3>
    <p>
      Inserta una fila, varias filas, duplica desde otra tabla, o resuelve conflictos con <code>ON DUPLICATE KEY UPDATE</code>.
    </p>
  <pre><code>-- Una y varias filas
  INSERT INTO productos (nombre, categoria, precio, stock)
  VALUES ('Altavoces', 'perifericos', 24.99, 40),
         ('Webcam', 'perifericos', 39.00, 30);
  
  -- INSERT ... SELECT (cargar desde otra tabla/consulta)
  INSERT INTO lineas_pedido (pedido_id, posicion, producto, cantidad, precio)
  SELECT 2, ROW_NUMBER() OVER (ORDER BY id), nombre, 1, precio
  FROM productos
  WHERE categoria = 'perifericos' AND precio &lt;= 25
  LIMIT 1;
  
  -- Resolver duplicados por clave única (ej.: email de clientes)
  INSERT INTO clientes (nombre, email)
  VALUES ('Ada L.','ada@ejemplo.com')
  ON DUPLICATE KEY UPDATE nombre = VALUES(nombre);
  
  -- REPLACE INTO (cuidado: borra e inserta; dispara ON DELETE)
  REPLACE INTO productos (id, nombre, categoria, precio, stock)
  VALUES (1, 'Libro BBDD (2ª ed.)', 'libros', 42.00, 40);
  </code></pre>
  
    <div class="callout warn">
      <strong>Seguridad en inserciones.</strong> Valida rangos y valores por defecto en el <em>DDL</em> (<code>NOT NULL</code>, <code>CHECK</code>). Evita depender solo de validaciones en la aplicación.
    </div>
  
    <h3>7) Actualizaciones (<code>UPDATE</code>)</h3>
    <p>
      Actualiza columnas con expresiones, usa <code>CASE</code> para reglas, y recuerda que puedes hacer <code>UPDATE ... JOIN</code> para aplicar cambios basados en otra tabla.
    </p>
  <pre><code>-- Subir precio un 5% en 'perifericos' con tope
  UPDATE productos
  SET precio = LEAST(precio * 1.05, 50)
  WHERE categoria = 'perifericos';
  
  -- Marcar clientes inactivos sin pedidos en 2 años
  UPDATE clientes c
  LEFT JOIN pedidos p
    ON p.cliente_id = c.id
    AND p.fecha_pedido &gt;= (CURRENT_DATE - INTERVAL 2 YEAR)
  SET c.activo = 0
  WHERE p.id IS NULL;
  
  -- Recalcular total de un pedido desde sus líneas
  UPDATE pedidos p
  JOIN (
    SELECT pedido_id, SUM(cantidad * precio) AS total_calc
    FROM lineas_pedido
    GROUP BY pedido_id
  ) t ON t.pedido_id = p.id
  SET p.total = t.total_calc
  WHERE p.id = 2;
  </code></pre>
  
    <h3>8) Borrados (<code>DELETE</code>)</h3>
    <p>
      Usa <code>DELETE</code> con <code>WHERE</code> (sin WHERE, borra toda la tabla). Para borrar con condición basada en otra tabla, utiliza <code>DELETE ... JOIN</code>. Para vaciar rápido toda la tabla y reiniciar <code>AUTO_INCREMENT</code>, <code>TRUNCATE TABLE</code> (ojo: es DDL).
    </p>
  <pre><code>-- Borrar productos sin stock y baratos
  DELETE FROM productos
  WHERE stock = 0 AND precio &lt; 10;
  
  -- Borrar líneas de pedidos cancelados
  DELETE lp
  FROM lineas_pedido lp
  JOIN pedidos p ON p.id = lp.pedido_id
  WHERE p.estado = 'cancelado';
  
  -- Vaciar tabla (reinicia AUTO_INCREMENT)
  TRUNCATE TABLE productos;
  </code></pre>
  
    <div class="callout tip">
      <strong>Modo seguro de MySQL Workbench/CLI.</strong> Si tienes activado <code>SQL_SAFE_UPDATES</code>, necesitas <code>WHERE</code> con clave o <code>LIMIT</code>. Puedes desactivarlo con <code>SET SQL_SAFE_UPDATES=0;</code> (mejor aprender a filtrar bien).
    </div>
  
    <h3>9) Operadores de conjuntos (<code>UNION</code> y <code>UNION ALL</code>)</h3>
    <p>
      Une resultados de varias consultas compatibles (mismo número y tipo de columnas). <code>UNION</code> elimina duplicados; <code>UNION ALL</code> los conserva.
    </p>
  <pre><code>-- Catálogo mixto: nombres que vengan de productos o de líneas de pedido
  SELECT nombre FROM productos
  UNION
  SELECT producto FROM lineas_pedido;
  </code></pre>
  
    <h3>10) (Opcional) Funciones de ventana</h3>
    <p>
      MySQL 8.0 incorpora <strong>ventanas</strong> (<code>OVER</code>), útiles para rankings y totales acumulados sin perder el detalle fila a fila.
    </p>
  <pre><code>-- Ranking de productos por precio dentro de su categoría
  SELECT categoria, nombre, precio,
         RANK() OVER (PARTITION BY categoria ORDER BY precio DESC) AS pos
  FROM productos;
  
  -- Total acumulado de ventas por cliente (ejemplo sobre pedidos)
  SELECT c.nombre, p.fecha_pedido, p.total,
         SUM(p.total) OVER (PARTITION BY c.id ORDER BY p.fecha_pedido) AS acumulado
  FROM clientes c
  JOIN pedidos p ON p.cliente_id = c.id
  ORDER BY c.nombre, p.fecha_pedido;
  </code></pre>
  
    <h3>11) Buenas prácticas y errores comunes</h3>
    <ul>
      <li>Evita <code>SELECT *</code> en producción: selecciona solo lo necesario.</li>
      <li>Filtra pronto: las condiciones en <code>WHERE</code> y los <em>joins</em> adecuados mejoran el plan.</li>
      <li>Comprueba planes con <code>EXPLAIN</code> cuando una consulta sea lenta.</li>
      <li>Cuida los índices que soportan tus filtros y joins más frecuentes.</li>
      <li>No uses <code>DELETE</code>/<code>UPDATE</code> masivos sin <code>WHERE</code> (y considera transacciones).</li>
    </ul>
  
    <h3>12) Ejercicios guiados</h3>
    <ol>
      <li>
        <strong>Una tabla:</strong> Lista los 3 productos más caros de cada categoría, mostrando categoría, nombre, precio y su posición dentro de la categoría (1–3).
        <details><summary>Solución orientativa</summary>
  <pre><code>WITH r AS (
    SELECT categoria, nombre, precio,
           ROW_NUMBER() OVER (PARTITION BY categoria ORDER BY precio DESC) AS rn
    FROM productos
  )
  SELECT categoria, nombre, precio, rn
  FROM r
  WHERE rn &lt;= 3
  ORDER BY categoria, rn;
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Agrupación:</strong> Muestra por categoría el número de productos con stock &gt; 0 y el precio medio.
        <details><summary>Solución orientativa</summary>
  <pre><code>SELECT categoria,
         COUNT(*) AS num,
         ROUND(AVG(precio),2) AS media
  FROM productos
  WHERE stock &gt; 0
  GROUP BY categoria;
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Varios joins:</strong> Saca el importe total por pedido (<code>SUM(cantidad*precio)</code>) junto con el nombre del cliente y la fecha, incluyendo pedidos sin líneas (importe 0).
        <details><summary>Solución orientativa</summary>
  <pre><code>SELECT p.id, c.nombre, p.fecha_pedido,
         COALESCE(SUM(lp.cantidad * lp.precio),0) AS importe
  FROM pedidos p
  JOIN clientes c ON c.id = p.cliente_id
  LEFT JOIN lineas_pedido lp ON lp.pedido_id = p.id
  GROUP BY p.id, c.nombre, p.fecha_pedido
  ORDER BY p.fecha_pedido DESC;
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Subconsulta correlacionada:</strong> Pedidos cuyo total es mayor que la media de sus pedidos del mismo cliente.
        <details><summary>Solución orientativa</summary>
  <pre><code>SELECT p.*
  FROM pedidos p
  WHERE p.total &gt; (
    SELECT AVG(p2.total) FROM pedidos p2 WHERE p2.cliente_id = p.cliente_id
  );
  </code></pre>
        </details>
      </li>
    </ol>
  </section>
  <!-- ===================== 3.c DML — CRUD EN MYSQL ===================== -->
<section id="dml-crud-mysql">
    <h2>3.c) DML en MySQL — Inserciones, actualizaciones y borrado (CRUD)</h2>
    <p>
      En DML no todo es <code>SELECT</code>. En el día a día insertamos nuevas filas (<code>INSERT</code>), modificamos datos existentes (<code>UPDATE</code>) y eliminamos filas (<code>DELETE</code>). También veremos variantes útiles como <code>INSERT ... SELECT</code>, <code>ON DUPLICATE KEY UPDATE</code>, <code>INSERT IGNORE</code>, <code>REPLACE</code>, actualizaciones/borrados con <em>JOIN</em>, y diferencias con <code>TRUNCATE</code>. Todo con <strong>MySQL 8.0+</strong> y el esquema del tema.
    </p>
  
    <!-- ===================== INSERT ===================== -->
    <h3>1) INSERT — insertar filas</h3>
    <p>
      La forma básica es indicar las columnas destino y los valores en el mismo orden. Si no indicas una columna, se aplica su <code>DEFAULT</code> (si lo tiene) o <code>NULL</code> (si lo permite). Para claves autoincrementales usa <code>AUTO_INCREMENT</code>. Tras un <code>INSERT</code>, recupera el identificador con <code>SELECT LAST_INSERT_ID();</code>
    </p>
  <pre><code>-- Una fila
  INSERT INTO clientes (nombre, email) 
  VALUES ('Grace Hopper','grace@ejemplo.com');
  
  -- Varias filas en una sola sentencia
  INSERT INTO productos (nombre, categoria, precio, stock) VALUES
    ('Auriculares', 'perifericos', 19.95, 40),
    ('SSD 1TB',    'almacenamiento', 89.00, 25);
  
  -- Insertar sin algunas columnas (usará DEFAULT o NULL)
  INSERT INTO pedidos (cliente_id, estado) VALUES (1, 'pendiente');
  
  -- Recuperar el último id autogenerado (sesión actual)
  SELECT LAST_INSERT_ID() AS nuevo_pedido_id;
  </code></pre>
  
    <h4>1.1) INSERT ... SELECT (cargar desde otra tabla/consulta)</h4>
    <p>
      Muy útil para migraciones o para duplicar datos transformados. La lista de columnas de destino debe ser compatible con la consulta.
    </p>
  <pre><code>-- Crear líneas copiando productos baratos como «regalos» del pedido 3
  INSERT INTO lineas_pedido (pedido_id, posicion, producto, cantidad, precio)
  SELECT 3,
         ROW_NUMBER() OVER (ORDER BY id) AS posicion,
         nombre,
         1 AS cantidad,
         0.00 AS precio
  FROM productos
  WHERE precio &lt;= 10;
  </code></pre>
  
    <h4>1.2) Manejo de duplicados</h4>
    <div class="callout info">
      <strong>Contexto.</strong> Cuando hay un índice <code>UNIQUE</code> (por ejemplo en <code>clientes.email</code>) un <code>INSERT</code> que lo rompa fallará. Tienes tres estrategias: <em>reemplazar</em>, <em>ignorar</em> o <em>fusionar/actualizar</em>.
    </div>
  <pre><code>-- a) ON DUPLICATE KEY UPDATE (upsert): si choca con una clave única, actualiza
  INSERT INTO clientes (nombre, email)
  VALUES ('Grace H.', 'grace@ejemplo.com')
  ON DUPLICATE KEY UPDATE nombre = VALUES(nombre);   -- véase nota abajo
  
  -- Nota: En MySQL 8.0.20+ la función VALUES() está deprecada.
  -- Alternativa moderna: alias de la fila insertada (cuando tu versión lo permita):
  -- INSERT INTO clientes AS nuevo (nombre, email)
  -- VALUES ('Grace H.', 'grace@ejemplo.com')
  -- ON DUPLICATE KEY UPDATE nombre = nuevo.nombre;
  
  -- b) INSERT IGNORE: no lanza error; las filas problemáticas se ignoran (¡ojo!)
  INSERT IGNORE INTO clientes (nombre, email)
  VALUES ('Duplicada','grace@ejemplo.com');
  
  -- c) REPLACE: borra la fila que choque y la inserta de nuevo (dispara ON DELETE + ON INSERT)
  REPLACE INTO clientes (id, nombre, email)
  VALUES (1, 'Grace H. (actualizada)', 'grace@ejemplo.com');
  </code></pre>
    <div class="callout warn">
      <strong>Advertencia.</strong> <code>INSERT IGNORE</code> puede ocultar problemas (datos truncados, <em>checks</em> que fallan, etc.). <code>REPLACE</code> elimina y vuelve a insertar: puede perder valores de otras columnas no incluidas y dispara disparadores (<em>triggers</em>). Para la mayoría de casos, prefiero <code>ON DUPLICATE KEY UPDATE</code>.
    </div>
  
    <!-- ===================== UPDATE ===================== -->
    <h3>2) UPDATE — modificar filas</h3>
    <p>
      Actualiza columnas con expresiones, funciones y condiciones. Recuerda que sin <code>WHERE</code> se actualiza <em>toda</em> la tabla. En MySQL Workbench y CLI suele estar activo <code>SQL_SAFE_UPDATES</code> (modo seguro), que exige <code>WHERE</code> por clave o <code>LIMIT</code>.
    </p>
  <pre><code>-- Subir el precio un 5% en «perifericos», con tope 50€
  UPDATE productos
  SET precio = LEAST(precio * 1.05, 50)
  WHERE categoria = 'perifericos';
  
  -- Reglas condicionales con CASE
  UPDATE productos
  SET precio = CASE
    WHEN categoria = 'libros' THEN precio * 0.95   -- 5% descuento
    WHEN stock &lt;= 5          THEN precio * 1.10   -- recargo por escasez
    ELSE precio
  END;
  
  -- Modo seguro (si bloquea la ejecución, desactívalo en tu sesión)
  -- SET SQL_SAFE_UPDATES = 0;
  </code></pre>
  
    <h4>2.1) UPDATE con JOIN (basado en otra tabla)</h4>
    <p>
      Muy potente para sincronizar campos entre tablas relacionadas o resultados agregados.
    </p>
  <pre><code>-- Recalcular el total del pedido 2 desde sus líneas
  UPDATE pedidos p
  JOIN (
    SELECT pedido_id, SUM(cantidad * precio) AS total_calc
    FROM lineas_pedido
    GROUP BY pedido_id
  ) t ON t.pedido_id = p.id
  SET p.total = t.total_calc
  WHERE p.id = 2;
  
  -- Desactivar clientes sin pedidos en los últimos 2 años
  UPDATE clientes c
  LEFT JOIN pedidos p
    ON p.cliente_id = c.id
    AND p.fecha_pedido &gt;= (CURRENT_DATE - INTERVAL 2 YEAR)
  SET c.activo = 0
  WHERE p.id IS NULL;
  </code></pre>
  
    <h4>2.2) ORDER BY y LIMIT en UPDATE</h4>
    <p>
      MySQL permite limitar cuántas filas actualizas y en qué orden. Útil para «trabajar por lotes».
    </p>
  <pre><code>-- Subir un céntimo a los 10 productos más baratos
  UPDATE productos
  SET precio = precio + 0.01
  ORDER BY precio ASC
  LIMIT 10;
  
  -- Filas afectadas en esta sesión
  SELECT ROW_COUNT() AS filas_modificadas;
  </code></pre>
  
    <!-- ===================== DELETE ===================== -->
    <h3>3) DELETE — eliminar filas</h3>
    <p>
      Igual que en <code>UPDATE</code>, si omites <code>WHERE</code> borrarás toda la tabla. Puedes borrar en base a otra tabla con <code>DELETE ... JOIN</code>. 
    </p>
  <pre><code>-- Borrar productos sin stock y baratos
  DELETE FROM productos
  WHERE stock = 0 AND precio &lt; 10;
  
  -- Borrar líneas de pedidos cancelados (apoyándonos en la tabla pedidos)
  DELETE lp
  FROM lineas_pedido lp
  JOIN pedidos p ON p.id = lp.pedido_id
  WHERE p.estado = 'cancelado';
  
  -- Borrar por lotes, controlando el número
  DELETE FROM lineas_pedido
  WHERE pedido_id = 3
  ORDER BY posicion DESC
  LIMIT 1;
  </code></pre>
  
    <h4>3.1) TRUNCATE vs DELETE vs DROP</h4>
    <div class="demo">
      <table>
        <thead><tr><th>Operación</th><th>Qué hace</th><th>Notas</th></tr></thead>
        <tbody>
          <tr>
            <td><code>DELETE FROM tabla</code></td>
            <td>Elimina filas según <code>WHERE</code></td>
            <td>Lento en tablas grandes (borra fila a fila). Respeta <em>triggers</em>. No reinicia <code>AUTO_INCREMENT</code> salvo que lo fuerces.</td>
          </tr>
          <tr>
            <td><code>TRUNCATE TABLE tabla</code></td>
            <td>Vacía toda la tabla</td>
            <td>Es DDL (implícitamente hace <code>COMMIT</code>), muy rápido, reinicia <code>AUTO_INCREMENT</code>, no dispara <em>triggers</em>. Requiere permisos más altos.</td>
          </tr>
          <tr>
            <td><code>DROP TABLE tabla</code></td>
            <td>Elimina la tabla y su definición</td>
            <td>Destruye también índices, permisos y datos. Irreversible salvo copia de seguridad.</td>
          </tr>
        </tbody>
      </table>
    </div>
  
    <!-- ===================== INTERACCIÓN CON REGLAS/TRANSACCIONES ===================== -->
    <h3>4) Integridad y transacciones: cómo afectan al CRUD</h3>
    <ul>
      <li><strong>Claves ajenas:</strong> un <code>DELETE</code> puede fallar si hay filas hijas sin una acción definida; usa <code>ON DELETE CASCADE</code> o <code>ON DELETE SET NULL</code> si es correcto en tu modelo.</li>
      <li><strong>CHECK/NOT NULL/UNIQUE:</strong> evitan que <code>INSERT</code>/<code>UPDATE</code> dejen datos inconsistentes. Prefiere validar en la BD además de en la app.</li>
      <li><strong>Transacciones (TCL):</strong> agrupa cambios dependientes con <code>START TRANSACTION</code> → <code>COMMIT</code> / <code>ROLLBACK</code>. Úsalo siempre en operaciones multi-tabla.</li>
    </ul>
  <pre><code>-- Alta de cliente y pedido de forma atómica
  START TRANSACTION;
    INSERT INTO clientes (nombre, email) VALUES ('Ada L.','ada@ejemplo.com');
    SET @id_cliente = LAST_INSERT_ID();
  
    INSERT INTO pedidos (cliente_id, estado, total)
    VALUES (@id_cliente, 'pendiente', 0);
  
    -- si todo va bien:
  COMMIT;
  -- si algo falla: ROLLBACK;
  </code></pre>
  
    <!-- ===================== PRÁCTICA ===================== -->
    <h3>5) Mini-prácticas rápidas</h3>
    <ol>
      <li>
        <strong>Upsert de productos.</strong> Inserta o actualiza el precio y el stock de un producto por su nombre (único).
        <details><summary>Solución orientativa</summary>
  <pre><code>ALTER TABLE productos ADD CONSTRAINT uq_prod_nombre UNIQUE (nombre);
  
  INSERT INTO productos (nombre, categoria, precio, stock)
  VALUES ('USB-C 64GB','almacenamiento', 14.99, 80)
  ON DUPLICATE KEY UPDATE
    precio = VALUES(precio),
    stock  = VALUES(stock);
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Actualizar por join.</strong> Sube un 10% el precio de todos los productos vendidos alguna vez.
        <details><summary>Solución orientativa</summary>
  <pre><code>UPDATE productos pr
  JOIN lineas_pedido lp ON lp.producto = pr.nombre
  SET pr.precio = pr.precio * 1.10;
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Borrado seguro.</strong> Borra como máximo 20 pedidos cancelados más antiguos, manteniendo un registro por si hay que deshacer.
        <details><summary>Solución orientativa</summary>
  <pre><code>START TRANSACTION;
    -- (opcional) copiar ids a una tabla temporal / registro
    CREATE TEMPORARY TABLE a_borrar AS
      SELECT id FROM pedidos
      WHERE estado = 'cancelado'
      ORDER BY fecha_pedido ASC
      LIMIT 20;
  
    DELETE p
    FROM pedidos p
    JOIN a_borrar t ON t.id = p.id;
  COMMIT;
  </code></pre>
        </details>
      </li>
    </ol>
  
    <div class="callout tip">
      <strong>Checklist mental antes de ejecutar un CRUD masivo:</strong>
      1) ¿Tengo <code>WHERE</code> correcto? 2) ¿Afectarán FKs/índices/triggers? 3) ¿Necesito transacción? 4) ¿He probado con <code>SELECT</code> previo? 5) ¿Debo limitar (<code>LIMIT</code>) o paginar por lotes?
    </div>
  </section>
<!-- ===================== 4.b DCL MYSQL A FONDO ===================== -->
<section id="dcl-mysql">
    <h2>4.b) DCL en MySQL — Usuarios, roles y privilegios (guía completa)</h2>
    <p>
      Con <strong>DCL</strong> definimos <em>quién</em> puede hacer <em>qué</em> en nuestra base de datos. En MySQL 8.0 trabajaremos con
      <strong>usuarios</strong> (<code>CREATE USER</code>, <code>ALTER USER</code>, <code>DROP USER</code>), <strong>roles</strong> (<code>CREATE ROLE</code>, <code>GRANT ... TO</code>),
      y <strong>privilegios</strong> (<code>GRANT</code>, <code>REVOKE</code>). Aplicaremos el principio de mínimo privilegio y veremos buenas prácticas para entornos reales.
    </p>
  
    <div class="demo">
      <table>
        <thead><tr><th>Nivel</th><th>Ámbito</th><th>Ejemplo de destino</th><th>Cuándo usar</th></tr></thead>
        <tbody>
          <tr><td>Global</td><td>Todo el servidor</td><td><code>*.*</code></td><td>Administración (evítalo para apps)</td></tr>
          <tr><td>Base de datos</td><td>Una BD</td><td><code>tienda.*</code></td><td>Permisos típicos de app</td></tr>
          <tr><td>Tabla / Vista</td><td>Objeto concreto</td><td><code>tienda.pedidos</code></td><td>Control fino</td></tr>
          <tr><td>Columna</td><td>Columnas específicas</td><td><code>tienda.clientes(email)</code></td><td>Informes parciales</td></tr>
          <tr><td>Rutina / Evento</td><td>Procedimientos, funciones, eventos</td><td><code>tienda.fn_calcular()</code></td><td>Ejecución controlada</td></tr>
        </tbody>
      </table>
    </div>
  
    <h3>1) Crear usuarios (identidad y seguridad)</h3>
    <p>
      Un usuario en MySQL es <code>'nombre'@'host'</code>. El <em>host</em> controla desde dónde se puede conectar (p. ej., <code>'app'@'localhost'</code> solo desde el propio servidor; <code>'app'@'%'</code> desde cualquier IP).
      En MySQL 8.0, el plugin de autenticación por defecto es <code>caching_sha2_password</code>.
    </p>
  <pre><code>-- Crear una usuaria de aplicación con contraseña fuerte
  CREATE USER 'app_ro'@'%' IDENTIFIED BY 'Contraseña#Segura#2025';
  
  -- Crear otro usuario restringido a conexiones locales
  CREATE USER 'app_rw'@'localhost' IDENTIFIED BY 'Otra#Fuerte#2025';
  
  -- Políticas: caducidad, bloqueo por intentos, etc.
  ALTER USER 'app_ro'@'%'
    PASSWORD EXPIRE INTERVAL 180 DAY
    FAILED_LOGIN_ATTEMPTS 6
    PASSWORD HISTORY 5
    PASSWORD REUSE INTERVAL 365 DAY;
  
  -- Reglas de conexión segura (si tu despliegue usa TLS)
  ALTER USER 'app_ro'@'%' REQUIRE SSL;
  
  -- Cambiar contraseña más tarde
  ALTER USER 'app_ro'@'%' IDENTIFIED BY 'Nueva#Contraseña#2026';
  </code></pre>
    <div class="callout tip">
      <strong>Consejo.</strong> Evita <code>'root'@'%'</code> y no uses cuentas de administración en la aplicación.
      Crea <em>usuarios de servicio</em> con permisos mínimos.
    </div>
  
    <h3>2) Privilegios: GRANT y REVOKE</h3>
    <p>
      Los privilegios más comunes: <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE</code>, <code>ALTER</code>,
      <code>DROP</code>, <code>INDEX</code>, <code>REFERENCES</code>, <code>CREATE VIEW</code>, <code>SHOW VIEW</code>, <code>TRIGGER</code>, <code>EVENT</code>, <code>EXECUTE</code>.
      Evita <code>FILE</code> salvo casos muy controlados.
    </p>
  <pre><code>-- Lectura en toda la BD 'tienda' (afecta a tablas actuales y futuras de esa BD)
  GRANT SELECT ON tienda.* TO 'app_ro'@'%';
  
  -- Lectura + escritura solo en tablas de negocio (ejemplo fino por tabla)
  GRANT SELECT, INSERT, UPDATE, DELETE ON tienda.pedidos       TO 'app_rw'@'localhost';
  GRANT SELECT, INSERT, UPDATE, DELETE ON tienda.lineas_pedido TO 'app_rw'@'localhost';
  
  -- Privilegios de definición (DDL) para tareas de mantenimiento
  GRANT CREATE, ALTER, INDEX, DROP ON tienda.* TO 'app_rw'@'localhost';
  
  -- Column-level: permitir UPDATE solo de 'telefono' y 'email' en clientes
  GRANT UPDATE (telefono, email) ON tienda.clientes TO 'app_rw'@'localhost';
  
  -- Revocar privilegios (siempre especifica el mismo ámbito que concediste)
  REVOKE INSERT, UPDATE ON tienda.pedidos FROM 'app_rw'@'localhost';
  
  -- Mostrar lo que tiene un usuario
  SHOW GRANTS FOR 'app_rw'@'localhost'\G
  </code></pre>
    <div class="callout warn">
      <strong>Con <code>WITH GRANT OPTION</code> cuidado.</strong> Permite a un usuario <em>redistribuir</em> privilegios.
      Evítalo en cuentas de aplicación; resérvalo para administración.
    </div>
  
    <h3>3) Roles (reutiliza conjuntos de privilegios)</h3>
    <p>
      Un <strong>rol</strong> agrupa privilegios y se puede otorgar a usuarios (¡incluso a otros roles!).
      Actívalo por defecto con <code>SET DEFAULT ROLE</code> para que se cargue al iniciar sesión.
    </p>
  <pre><code>-- 1) Definir roles
  CREATE ROLE 'rol_lectura', 'rol_escritura';
  
  -- 2) Dar privilegios a los roles
  GRANT SELECT ON tienda.* TO 'rol_lectura';
  GRANT SELECT, INSERT, UPDATE, DELETE ON tienda.* TO 'rol_escritura';
  
  -- 3) Asignar roles a usuarios (con o sin capacidad de administrarlos)
  GRANT 'rol_lectura'  TO 'app_ro'@'%';
  GRANT 'rol_escritura' TO 'app_rw'@'localhost' WITH ADMIN OPTION;
  
  -- 4) Activar roles por defecto para cada usuario
  SET DEFAULT ROLE 'rol_lectura'  TO 'app_ro'@'%';
  SET DEFAULT ROLE 'rol_escritura' TO 'app_rw'@'localhost';
  
  -- Comprobar
  SHOW GRANTS FOR 'app_ro'@'%'\G
  </code></pre>
    <div class="callout info">
      <strong>BD completa vs. tabla suelta.</strong> Dar permisos a nivel <em>base de datos</em> (p. ej., <code>tienda.*</code>)
      aplica a tablas existentes <em>y a las que se creen después</em> en esa BD. Para casos especiales, complementa con tabla/columna.
    </div>
  
    <h3>4) Vistas con seguridad controlada</h3>
    <p>
      Las <strong>vistas</strong> permiten exponer un subconjunto de datos. Con <code>SQL SECURITY DEFINER</code> la vista se ejecuta con
      los privilegios de su creador (ideal para encapsular reglas de acceso).
    </p>
  <pre><code>-- Vista de solo lectura con columnas permitidas
  CREATE VIEW v_clientes_publicos
  SQL SECURITY DEFINER
  AS
  SELECT id, nombre, email
  FROM tienda.clientes;
  
  -- Dar permiso solo sobre la vista, no sobre la tabla
  GRANT SELECT ON tienda.v_clientes_publicos TO 'app_ro'@'%';
  </code></pre>
  
    <h3>5) Gestión del ciclo de vida: renombrar, bloquear, borrar</h3>
  <pre><code>-- Bloquear una cuenta temporalmente (no puede autenticarse)
  ALTER USER 'app_rw'@'localhost' ACCOUNT LOCK;
  
  -- Desbloquear
  ALTER USER 'app_rw'@'localhost' ACCOUNT UNLOCK;
  
  -- Renombrar usuario (útil en migraciones)
  RENAME USER 'app_rw'@'localhost' TO 'app_writer'@'localhost';
  
  -- Borrar usuario (se revocan sus roles/privilegios automáticamente)
  DROP USER IF EXISTS 'app_writer'@'localhost';
  </code></pre>
  
    <h3>6) Cómo decide MySQL qué usuario coincide (resolución <code>user@host</code>)</h3>
    <p>
      Si existen varias entradas que podrían coincidir (p. ej., <code>'ana'@'localhost'</code> y <code>'ana'@'%'</code>), MySQL elige la más específica.
      Revisa con <code>SELECT user, host FROM mysql.user ORDER BY host;</code> para detectar solapamientos.
    </p>
  
    <h3>7) Buenas prácticas de seguridad</h3>
    <ul>
      <li>Principio de <strong>mínimo privilegio</strong>: da solo lo imprescindible.</li>
      <li>Separa <em>cuentas de administración</em> de <em>cuentas de aplicación</em>.</li>
      <li>Usa <strong>roles</strong> para estandarizar permisos y simplificar auditorías.</li>
      <li>Revisa periódicamente con <code>SHOW GRANTS</code> y elimina cuentas que no se usan (<em>account hygiene</em>).</li>
      <li>Activa políticas de <strong>contraseña</strong> (caducidad, intentos fallidos, complejidad) y, si procede, <strong>TLS</strong> (<code>REQUIRE SSL</code>).</li>
      <li>Evita <code>FILE</code> y privilegios globales para usuarios de app.</li>
    </ul>
  
    <h3>8) Escenarios prácticos</h3>
    <ol>
      <li>
        <strong>Solo lectura para analistas externos</strong> (acceso desde cualquier IP, sin redistribuir permisos).
        <details><summary>Solución orientativa</summary>
  <pre><code>CREATE USER 'analista'@'%' IDENTIFIED BY 'Analista#2025';
  GRANT SELECT ON tienda.* TO 'analista'@'%';
  -- impedir que delegue permisos:
  -- (no usamos WITH GRANT OPTION)
  SHOW GRANTS FOR 'analista'@'%'\G
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Aplicación con CRUD limitado</strong> (sin DROP/ALTER).
        <details><summary>Solución orientativa</summary>
  <pre><code>CREATE USER 'app'@'%' IDENTIFIED BY 'App#2025';
  GRANT SELECT, INSERT, UPDATE, DELETE ON tienda.* TO 'app'@'%';
  -- nada de DDL ni privilegios peligrosos
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Permitir edición solo de ciertas columnas sensibles</strong> (p. ej., teléfono y email).
        <details><summary>Solución orientativa</summary>
  <pre><code>GRANT UPDATE (telefono, email) ON tienda.clientes TO 'app'@'%';
  REVOKE UPDATE ON tienda.clientes FROM 'app'@'%'; -- elimina UPDATE global a la tabla si lo tuviera
  </code></pre>
        </details>
      </li>
    </ol>
  
    <div class="callout warn">
      <strong>Errores típicos.</strong>
      1) Dar permisos en <code>*.*</code> a cuentas de app. 2) Usar <code>'%'</code> sin necesidad (prefiere rangos/hosts concretos).
      3) Olvidar <code>SET DEFAULT ROLE</code> tras asignar roles. 4) Conceder <code>WITH GRANT OPTION</code> a usuarios no administradores.
    </div>
  </section>
        
            <!-- ===================== 5.b TCL MYSQL A FONDO ===================== -->
<section id="tcl-mysql">
    <h2>5.b) TCL en MySQL — Transacciones en profundidad</h2>
    <p>
      <strong>TCL</strong> (Transaction Control Language) nos da el control sobre cómo se aplican o deshacen los cambios en la base de datos. En MySQL (InnoDB) trabajamos con <code>START TRANSACTION</code>/<code>BEGIN</code>, <code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code> y los <strong>niveles de aislamiento</strong>. Además, entenderemos cómo funcionan los <em>bloqueos</em> (row locks) y la <em>lectura consistente</em> (MVCC) para evitar sorpresas en concurrencia.
    </p>
  
    <h3>1) Autocommit y transacciones explícitas</h3>
    <p>
      Por defecto MySQL suele tener <code>autocommit=1</code>: cada sentencia DML se confirma sola. Para agrupar varias operaciones dependientes, desactiva autocommit o usa una transacción explícita.
    </p>
  <pre><code>-- Ver/ajustar autocommit (sesión actual)
  SHOW VARIABLES LIKE 'autocommit';
  SET autocommit = 0;     -- a partir de ahora, cada sentencia queda pendiente hasta COMMIT
  
  -- Patrón recomendado: transacción explícita
  START TRANSACTION;       -- opcional: START TRANSACTION READ WRITE;
    -- ... tus INSERT/UPDATE/DELETE aquí ...
  COMMIT;                  -- aplica los cambios
  -- ROLLBACK;             -- si hubo error, deshazlo
  
  -- Volver a autocommit si quieres
  SET autocommit = 1;
  </code></pre>
  
    <h4>1.1) Ejemplo completo: alta de pedido atómica</h4>
    <p>
      Alta de pedido + líneas + recálculo del total. Si algo falla, nada queda a medias.
    </p>
  <pre><code>START TRANSACTION;
  
    INSERT INTO pedidos (cliente_id, estado, total)
    VALUES (1, 'pendiente', 0);
  
    SET @id_pedido := LAST_INSERT_ID();
  
    INSERT INTO lineas_pedido (pedido_id, posicion, producto, cantidad, precio) VALUES
      (@id_pedido, 1, 'Libro BBDD', 1, 38.50),
      (@id_pedido, 2, 'Ratón', 1, 20.00);
  
    -- recalcular total desde las líneas
    UPDATE pedidos p
    JOIN (
      SELECT pedido_id, SUM(cantidad * precio) AS total_calc
      FROM lineas_pedido
      WHERE pedido_id = @id_pedido
      GROUP BY pedido_id
    ) t ON t.pedido_id = p.id
    SET p.total = t.total_calc;
  
  COMMIT;
  </code></pre>
  
    <div class="callout tip">
      <strong>Consejo.</strong> Antes de confirmar, valida supuestos (existencias, importes no negativos, etc.). Si algo no cuadra, <code>ROLLBACK;</code>.
    </div>
  
    <h3>2) SAVEPOINT, ROLLBACK TO y RELEASE</h3>
    <p>
      Los <strong>savepoints</strong> permiten “marcar” puntos intermedios para deshacer <em>parcialmente</em> sin perder toda la transacción.
    </p>
  <pre><code>START TRANSACTION;
    -- operaciones A
    SAVEPOINT sp_despues_A;
  
    -- operaciones B (arriesgadas)
    -- ...
    -- Si algo sale mal:
    ROLLBACK TO sp_despues_A;  -- deshace solo B; A se mantiene
  
    -- seguimos con C...
    RELEASE SAVEPOINT sp_despues_A;  -- opcional: libera el savepoint
  COMMIT;
  </code></pre>
  
    <h3>3) Niveles de aislamiento</h3>
    <p>
      Controlan qué fenómenos de concurrencia toleramos. InnoDB por defecto usa <strong>REPEATABLE READ</strong>. A mayor aislamiento, menos anomalías… y potencialmente menos concurrencia.
    </p>
    <div class="demo">
      <table>
        <thead><tr><th>Nivel</th><th>Lecturas sucias</th><th>No repetibles</th><th>Fantasmas</th></tr></thead>
        <tbody>
          <tr><td>READ UNCOMMITTED</td><td>posibles</td><td>posibles</td><td>posibles</td></tr>
          <tr><td>READ COMMITTED</td><td>no</td><td>posibles</td><td>posibles</td></tr>
          <tr><td>REPEATABLE READ (InnoDB por defecto)</td><td>no</td><td>no</td><td>mitigadas con <em>next-key locks</em></td></tr>
          <tr><td>SERIALIZABLE</td><td>no</td><td>no</td><td>no (equivale a ejecutar en serie)</td></tr>
        </tbody>
      </table>
    </div>
  <pre><code>-- Fijar el aislamiento para la siguiente transacción
  SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
  START TRANSACTION;
    -- ... consultas y DML aquí se ejecutan con READ COMMITTED ...
  COMMIT;
  
  -- Fijarlo para toda la sesión
  SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  </code></pre>
  
    <h3>4) Lectura consistente (MVCC) y SELECT con bloqueo</h3>
    <p>
      Con MVCC, una consulta “ve” un <em>snapshot</em> consistente. Si necesitas <strong>bloquear</strong> filas para evitar que otra transacción las cambie (p. ej., al calcular stock), usa <code>SELECT ... FOR UPDATE</code> (bloqueo exclusivo) o <code>SELECT ... FOR SHARE</code> (bloqueo compartido).
    </p>
  <pre><code>START TRANSACTION;
  
    -- Bloquear una fila de productos para actualización de stock
    SELECT id, stock
    FROM productos
    WHERE id = 10
    FOR UPDATE;   -- evita que otra transacción la modifique hasta COMMIT/ROLLBACK
  
    -- comprobar stock y actualizar
    UPDATE productos SET stock = stock - 1 WHERE id = 10 AND stock &gt; 0;
  
  COMMIT;
  </code></pre>
    <div class="callout info">
      <strong>Matiz.</strong> <code>FOR SHARE</code> ofrece lectura con bloqueo compartido (antes se usaba <code>LOCK IN SHARE MODE</code>). En versiones recientes existen variantes para cola de trabajo (<em>NOWAIT</em> / <em>SKIP LOCKED</em>) si tu servidor las soporta.
    </div>
  
    <h3>5) Deadlocks y lock waits: cómo reconocerlos y actuar</h3>
    <p>
      Un <strong>deadlock</strong> aparece cuando dos transacciones se esperan mutuamente. InnoDB detecta el ciclo y aborta una de ellas con error para liberar el bloqueo. Estrategia: <em>captura el error, haz ROLLBACK y reintenta</em>.
    </p>
  <pre><code>-- Escenario didáctico (dos sesiones)
  -- Sesión A
  START TRANSACTION;
  UPDATE productos SET precio = precio + 1 WHERE id = 1;
  -- (sin COMMIT) ahora intenta:
  UPDATE productos SET precio = precio + 1 WHERE id = 2;
  
  -- Sesión B
  START TRANSACTION;
  UPDATE productos SET precio = precio + 1 WHERE id = 2;
  -- (sin COMMIT) ahora intenta:
  UPDATE productos SET precio = precio + 1 WHERE id = 1;
  -- InnoDB detectará deadlock en una de las sesiones
  </code></pre>
    <div class="callout tip">
      <strong>Evítalos con orden consistente.</strong> Actualiza filas en el mismo orden en todas las transacciones (por ejemplo, siempre por <code>id</code> ascendente). Usa índices adecuados para que el <em>where</em> seleccione por clave y reduzca bloqueos.
    </div>
    <div class="callout warn">
      <strong>Diagnóstico.</strong> Si necesitas detalles, consulta el último conflicto en <code>SHOW ENGINE INNODB STATUS\G</code> o las vistas de <em>performance_schema</em> relacionadas con bloqueos si están activadas. 
    </div>
  
    <h3>6) DDL y <em>commits</em> implícitos</h3>
    <p>
      En MySQL, muchas sentencias DDL fuerzan <strong>commits implícitos</strong> antes y después de ejecutarse (p. ej., <code>CREATE/DROP/ALTER TABLE</code>, <code>TRUNCATE</code>, <code>CREATE/DROP DATABASE</code>, <code>LOCK/UNLOCK TABLES</code>). No puedes incluirlas “a medias” en una transacción y esperar deshacerlas.
    </p>
  <pre><code>START TRANSACTION;
    DELETE FROM pedidos WHERE estado = 'cancelado';
    -- ¡Ojo! Esto hace commit implícito, no es parte de la transacción:
    TRUNCATE TABLE log_temporal;
  -- COMMIT aquí no afectará al TRUNCATE anterior
  </code></pre>
  
    <h3>7) Patrón práctico: “disminuir stock” de forma segura</h3>
    <p>
      Disminuir stock debe ser <em>atómico</em> y evitar condiciones de carrera. Bloqueamos la fila de producto, validamos, y aplicamos el cambio.
    </p>
  <pre><code>START TRANSACTION;
  
    -- bloquear fila del producto
    SELECT stock FROM productos WHERE id = 42 FOR UPDATE;
  
    -- verificar disponibilidad
    -- (si no hay stock, ROLLBACK y notificar)
    UPDATE productos
    SET stock = stock - 1
    WHERE id = 42 AND stock &gt; 0;
  
    -- comprobar que realmente se afectó 1 fila
    SELECT ROW_COUNT() AS filas_afectadas;
  
    -- opcional: registrar movimiento, insertar línea de pedido, etc.
  
  COMMIT;
  </code></pre>
  
    <h3>8) Errores comunes y buenas prácticas</h3>
    <ul>
      <li>Olvidar <strong>COMMIT/ROLLBACK</strong>: deja bloqueos abiertos y sesiones colgadas.</li>
      <li>Mezclar <strong>DDL</strong> en mitad de una lógica DML crítica: provoca <em>commits</em> implícitos.</li>
      <li>Asumir que <strong>SELECT</strong> “ve” cambios de otra transacción sin confirmar: con MVCC no es así (salvo que bloquees explícitamente).</li>
      <li>No controlar errores de <strong>deadlock</strong> o <strong>lock wait timeout</strong>: añade un pequeño <em>retry</em> exponencial.</li>
      <li>Elegir niveles de aislamiento sin medir: empieza con <em>READ COMMITTED</em> o <em>REPEATABLE READ</em> según tu caso, y perfila.</li>
    </ul>
  
    <h3>9) Mini-prácticas guiadas</h3>
    <ol>
      <li>
        <strong>Rollback parcial.</strong> Inserta dos líneas de pedido; simula un error en la segunda y usa <code>SAVEPOINT</code> para deshacer solo esa parte y confirmar el resto.
        <details><summary>Solución orientativa</summary>
  <pre><code>START TRANSACTION;
    INSERT INTO lineas_pedido VALUES (3,1,'USB-C',1,9.99);
    SAVEPOINT sp;
    INSERT INTO lineas_pedido VALUES (3,2,'Portátil 14&quot;',1,-1.00); -- viola CHECK
    -- error: deshacer solo la segunda
    ROLLBACK TO sp;
  COMMIT;
  </code></pre>
        </details>
      </li>
      <li>
        <strong>Comparar aislamientos.</strong> En dos sesiones, con <em>READ COMMITTED</em> y <em>REPEATABLE READ</em>, observa si una consulta repetida ve cambios confirmados por la otra sesión.
        <details><summary>Guía</summary>
          Ejecuta <code>SET SESSION TRANSACTION ISOLATION LEVEL ...</code>, empieza una transacción, lanza <code>SELECT</code> y repítela tras un <code>UPDATE</code> confirmado desde otra sesión. Compara resultados.
        </details>
      </li>
      <li>
        <strong>Evitar deadlocks.</strong> Diseña una actualización multi-fila que siempre recorra IDs en orden ascendente en todas las sesiones. Verifica que no se producen interbloqueos.
      </li>
    </ol>
  </section>
  
</main>
</div>

<a href="#top" class="backtotop" aria-label="Volver arriba">↑</a>

<footer class="site-footer" role="contentinfo" class="wrap">
  <div>
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer" title="CC BY-NC-SA 4.0">
      <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Licencia Creative Commons BY-NC-SA 4.0">
    </a>
  </div>
</footer>

<!-- JS de navegación (ajustado a tus clases e IDs) -->
<script>
(function(){
  // Topbar toggle
  var btn = document.querySelector('.topnav-toggle');
  var nav = document.getElementById('topnav');
  if (btn && nav) {
    btn.addEventListener('click', function(){
      var open = nav.classList.toggle('open');
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    });
    nav.addEventListener('click', function(e){
      if (e.target.tagName === 'A' && nav.classList.contains('open')) {
        nav.classList.remove('open');
        btn.setAttribute('aria-expanded', 'false');
      }
    });
  }

  // Resalta enlace activo en el TOC según sección visible
  var links = document.querySelectorAll('.toc a[href^="#"]');
  var targets = Array.prototype.map.call(links, function(a){
    try { return document.querySelector(a.getAttribute('href')); } catch(e){ return null; }
  }).filter(Boolean);

  if ('IntersectionObserver' in window) {
    var obs = new IntersectionObserver(function(entries){
      entries.forEach(function(entry){
        if (entry.isIntersecting) {
          var id = '#' + entry.target.id;
          links.forEach(function(a){
            a.classList.toggle('active', a.getAttribute('href') === id);
          });
        }
      });
    }, { rootMargin: "-40% 0px -55% 0px", threshold: 0 });
    targets.forEach(function(t){ obs.observe(t); });
  }
})();
</script>
</body>
</html>
